1.函数参数的默认值<br>
在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。

      function log(x, y) {
        y = y || 'World';
        console.log(x, y);
      }
      
      log('Hello') // Hello World
      log('Hello', 'China') // Hello China
      log('Hello', '') // Hello World
      
上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。<br>

这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。<br>

就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。<br>

为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。<br>

    if (typeof y === 'undefined') {
      y = 'World';
    }
    
<h3>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</h3>

    function log(x, y = 'World') {
      console.log(x, y);
    }
    
    log('Hello') // Hello World
    log('Hello', 'China') // Hello China
    log('Hello', '') // Hello

与解构赋值默认值结合使用

    function foo({x, y = 5}) {
      console.log(x, y);
    }
    
    foo({}) // undefined, 5
    foo({x: 1}) // 1, 5
    foo({x: 1, y: 2}) // 1, 2
    foo() // TypeError: Cannot read property 'x' of undefined

参数默认值的位置

    function f(x = 1, y) {
      return [x, y];
    }
    
    f() // [1, undefined]
    f(2) // [2, undefined])
    f(, 1) // 报错
    f(undefined, 1) // [1, 1]
    
    // 例二
    function f(x, y = 5, z) {
      return [x, y, z];
    }
    
    f() // [undefined, 5, undefined]
    f(1) // [1, 5, undefined]
    f(1, ,2) // 报错
    f(1, undefined, 2) // [1, 5, 2]
    

rest参数<br>

ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

    function add(...values) {
      let sum = 0;
    
      for (var val of values) {
        sum += val;
      }
    
      return sum;
    }

    add(2, 5, 3) // 10
    

<h3>扩展运算符 ...</h3>

扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。

      console.log(...[1, 2, 3])
      // 1 2 3
      
      console.log(1, ...[2, 3, 4], 5)
      // 1 2 3 4 5
      
      [...document.querySelectorAll('div')]
      // [<div>, <div>, <div>]
      










